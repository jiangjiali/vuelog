title: Transit机密引擎
------------------------------------
<!-- zh-CN:+ -->
Transit机密引擎处理传输中数据的加密功能。安全库不存储发送到机密引擎的数据。它也可以被视为“加密即服务”或“解密即服务”。transit机密引擎还可以对数据进行签名和验证；生成数据的哈希和hmac；并充当随机字节的源。

“transit”的主要用例是加密来自应用程序的数据，同时仍将加密数据存储在一些主数据存储中。这减轻了应用程序开发人员对正确加密/解密的负担，并将负担推到了保险库的操作人员身上。

支持密钥派生，通过基于用户提供的上下文值派生新密钥，允许同一密钥用于多种用途。在这种模式下，可以选择性地支持收敛加密，允许相同的输入值产生相同的密文。

数据密钥生成允许进程请求将给定位长度的高熵密钥返回给它们，并用命名密钥加密。通常，这也将以明文形式返回密钥，以便立即使用，但可以禁用此操作以满足审核要求。

[»](#工作集管理)工作集管理
--------------------------------------------------

传输引擎支持密钥的版本控制。早于密钥指定的“min_decryption_version”的密钥版本将被存档，其余密钥版本属于工作集。这是保持密钥加载速度的一个性能考虑因素，也是一个安全考虑因素：由于不允许解密旧版本的密钥，大多数用户无法解密与过时（但敏感）数据相对应的密文，但在紧急情况下，可以将“min_decryption”版本移回以允许合法解密。

当前，此存档存储在单个存储条目中。对于某些存储后端，尤其是那些使用Raft或Paxos实现HA功能的后端，频繁的轮换可能会导致归档的存储条目大小大于存储后端可以处理的大小。对于频繁的旋转需要，使用与时间范围（例如，五分钟周期与五个最接近的倍数相对应）相对应的命名关键点可以提供一个很好的替代方法，允许多个关键点同时处于活动状态，并且可以确定在任何给定时间决定使用哪个键。

[»](#健类型)健类型
------------------------

目前，transit机密引擎支持以下密钥类型（所有密钥类型还生成单独的HMAC密钥）：

*   [`aes128-gcm96`](#aes128-gcm96): AES-GCM，具有128位AES密钥和96位nonce；支持加密、解密、密钥派生和收敛加密
*   [`aes256-gcm96`](#aes256-gcm96): AES-GCM，256位AES密钥和96位nonce；支持加密、解密、密钥派生和收敛加密（默认）
*   [`chacha20-poly1305`](#chacha20-poly1305): ChaCha20-Poly1305，256位密钥；支持加密、解密、密钥派生和收敛加密
*   [`ed25519`](#ed25519): Ed25519；支持签名、签名验证和密钥派生
*   [`ecdsa-p256`](#ecdsa-p256): ECDSA使用曲线P-256；支持签名和签名验证
*   [`ecdsa-p384`](#ecdsa-p384): ECDSA使用曲线P-384；支持签名和签名验证
*   [`ecdsa-p521`](#ecdsa-p521): ECDSA使用曲线P-521；支持签名和签名验证
*   [`rsa-2048`](#rsa-2048): 2048位RSA密钥；支持加密、解密、签名和签名验证
*   [`rsa-3072`](#rsa-3072): 3072位RSA密钥；支持加密、解密、签名和签名验证
*   [`rsa-4096`](#rsa-4096): 4096位RSA密钥；支持加密、解密、签名和签名验证

[»](#收敛加密)收敛加密
------------------------------------------------

收敛加密是一种模式，在这种模式下，同一组明文+上下文总是产生相同的密文。它通过使用密钥派生函数来派生密钥，也通过确定地派生nonce来实现。由于这些属性对于大小为2^256的密钥空间上的明文和密文的任何组合都是不同的，因此一次性重用的风险几乎为零。

这有许多实际用途。一种常见的使用模式是允许将值加密存储在数据库中，但对查找/查询的支持有限，因此可以从查询中返回特定字段具有相同值的行。

为了适应对算法的任何必要升级，过去支持不同版本的收敛加密：

*   版本1 要求客户机提供自己的nonce，这是非常灵活的，但是如果做得不正确会很危险。这仅在安全库v0.6.1中存在，使用此版本的密钥无法升级。
*   版本2 使用算法方法来推导参数。然而，所使用的算法容易受到脱机明文确认攻击，如果明文大小很小，攻击者可以使用暴力进行解密。使用版本2的密钥可以通过简单地执行旋转操作升级到新的密钥版本；然后可以针对新密钥版本重新捕获现有值，并将使用版本3算法。
*   版本3 使用了一种不同的算法，旨在抵抗脱机明文确认攻击。它类似于AES-SIV，因为它使用PRF从明文生成nonce。

[»](#安装)安装
----------------

大多数秘密引擎必须事先配置好才能执行其功能。这些步骤通常由操作员或配置管理工具完成。

1.  启用transit机密引擎：
    
    ```
    $ vault secrets enable transit
    Success! Enabled the transit secrets engine at: transit/
    
    ```
    
    默认情况下，机密引擎将安装在引擎的名称处。要在其他路径上启用机密引擎，请使用“-path”参数。
    
2.  创建命名加密密钥：
    
    ```
    $ vault write -f transit/keys/my-key
    Success! Data written to: transit/keys/my-key
    
    ```
    
    通常每个应用程序都有自己的加密密钥。
    

[»](#使用)使用
----------------

在配置机密引擎并且用户/计算机具有具有适当权限的保险库令牌之后，它可以使用此机密引擎。

1.  使用带有命名密钥的“/encrypt”终结点加密某些明文数据：
    
    **注意：**所有明文数据**必须是base64编码的**。这一要求的原因是，Vault不要求明文是“文本”。它可以是二进制文件，如PDF或图像。将此数据作为JSON有效负载的一部分，最简单的安全传输机制是对其进行base64编码。
    
    ```
    $ vault write transit/encrypt/my-key plaintext=$(base64 <<< \"my secret data\")
    
    Key           Value
    ---           -----
    ciphertext    vault:v1:8SDd3WHDOjf7mq69CyCqYjBXAiQQAVZRkFM13ok481zoCmHnSeDX9vyf7w==
    
    ```
    
    返回的密文以`vault:v1:`. 第一个前缀（`vault`）表示它已被安全库包装。“v1”表示密钥版本1用于加密明文；因此，当您旋转密钥时，安全库知道要使用哪个版本进行解密。其余的是初始化向量（IV）和密文的base64级联。
    
    请注意，安全库不存储任何这些数据。调用者负责存储加密密文。当调用方需要明文时，它必须将密文提供回保险库以解密该值。
    
    为了防止拒绝服务攻击，安全库HTTP API的最大请求大小为32MB。可在“每个侦听器”块中对每个“安全库”配置进行调整。
    
2.  使用带命名密钥的“/decrypt”终结点解密数据段：
    
    ```
    $ vault write transit/decrypt/my-key ciphertext=vault:v1:8SDd3WHDOjf7mq69CyCqYjBXAiQQAVZRkFM13ok481zoCmHnSeDX9vyf7w==
    
    Key          Value
    ---          -----
    plaintext    bXkgc2VjcmV0IGRhdGEK
    
    ```
    
    得到的数据是base64编码的（有关原因的详细信息，请参见上面的注释）。对其进行解码以获得原始明文：
    
    ```
    $ base64 --decode <<< "bXkgc2VjcmV0IGRhdGEK"
    my secret data
    
    ```
    
    也可以在一个命令中使用一些聪明的shell脚本编写此解密脚本：
    
    ```
    $ vault write -field=plaintext transit/decrypt/my-key ciphertext=... | base64 --decode
    my secret data
    
    ```
    
    使用acl，可以限制使用transit机密引擎，以便受信任的操作员可以管理命名密钥，并且应用程序只能使用它们需要访问的命名密钥来加密或解密。
    
3.  旋转基础加密密钥。这将生成一个新的加密密钥，并将其添加到指定密钥的密钥环中：
    
    ```
    $ vault write -f transit/keys/my-key/rotate
    Success! Data written to: transit/keys/my-key/rotate
    
    ```
    
    将来的加密将使用这个新密钥。由于使用了密钥环，旧数据仍然可以解密。
    
4.  将已加密的数据升级为新密钥。安全库将使用密钥环中适当的密钥对值进行解密，然后使用密钥环中最新的密钥对生成的明文进行加密。
    
    ```
    $ vault write transit/rewrap/my-key ciphertext=vault:v1:8SDd3WHDOjf7mq69CyCqYjBXAiQQAVZRkFM13ok481zoCmHnSeDX9vyf7w==
    
    Key           Value
    ---           -----
    ciphertext    vault:v2:0VHTTBb2EyyNYHsa3XiXsvXOQSLKulH+NqS4eRZdtc2TwQCxqJ7PUipvqQ==
    
    ```
    
    此进程**不会**显示明文数据。因此，保险库策略可以授予几乎不受信任的进程“重写”加密数据的能力，因为该进程无法访问明文数据。

<!-- zh-CN:- -->